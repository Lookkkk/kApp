<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <script src="jquery-3.2.1.min.js"></script>
</head>
<body>
<div id="container"></div>
<script>
    function ReactDOMTextComponent(text) {
        //存下当前的字符串
        this._currentElement = '' + text;
        //用来标识当前component
        this._rootNodeID = null;
    }

    //component渲染时生成的dom结构
    ReactDOMTextComponent.prototype.mountComponent = function (rootID) {
        this._rootNodeID = rootID;
        return '<span data-reactid="' + rootID + '">' + this._currentElement + '</span>';
    };

    function ReactElement(type, key, props) {
        this.type = type;
        this.key = key;
        this.props = props;
    }

    function ReactDOMComponent(element) {
        //存下当前的element对象引用
        this._currentElement = element;
        this._rootNodeID = null;
    }

    //component渲染时生成的dom结构
    ReactDOMComponent.prototype.mountComponent = function (rootID) {
        //赋值标识
        this._rootNodeID = rootID;
        var props = this._currentElement.props;
        var tagOpen = '<' + this._currentElement.type;
        var tagClose = '</' + this._currentElement.type + '>';

        //加上reactid标识
        tagOpen += ' data-reactid=' + this._rootNodeID;

        //拼凑出属性
        for (var propKey in props) {

            //这里要做一下事件的监听，就是从属性props里面解析拿出on开头的事件属性的对应事件监听
            if (/^on[A-Za-z]/.test(propKey)) {
                var eventType = propKey.replace('on', '');
                //针对当前的节点添加事件代理,以_rootNodeID为命名空间
                $(document).delegate('[data-reactid="' + this._rootNodeID + '"]', eventType + '.' + this._rootNodeID, props[propKey]);
            }

            //对于children属性以及事件监听的属性不需要进行字符串拼接
            //事件会代理到全局。这边不能拼到dom上不然会产生原生的事件监听
            if (props[propKey] && propKey != 'children' && !/^on[A-Za-z]/.test(propKey)) {
                tagOpen += ' ' + propKey + '=' + props[propKey];
            }
        }
        //获取子节点渲染出的内容
        var content = '';
        var children = props.children || [];

        var childrenInstances = []; //用于保存所有的子节点的componet实例，以后会用到
        var that = this;
        $.each(children, function (key, child) {
            //这里再次调用了instantiateReactComponent实例化子节点component类，拼接好返回
            var childComponentInstance = instantiateReactComponent(child);
            childComponentInstance._mountIndex = key;

            childrenInstances.push(childComponentInstance);
            //子节点的rootId是父节点的rootId加上新的key也就是顺序的值拼成的新值
            var curRootId = that._rootNodeID + '.' + key;
            //得到子节点的渲染内容
            var childMarkup = childComponentInstance.mountComponent(curRootId);
            //拼接在一起
            content += ' ' + childMarkup;

        });

        //留给以后更新时用的这边先不用管
        this._renderedChildren = childrenInstances;

        //拼出整个html内容
        return tagOpen + '>' + content + tagClose;
    };

    var ReactClass = function () {

    };
    ReactClass.prototype.render = function () {

    };
    React = {
        nextReactRootIndex: 0,
        createClass: function (spec) {
            var Constructor = function (props) {
                this.props = props;
                this.state = this.getInitialState ? this.getInitialState() : null;
            };
            Constructor.prototype = new ReactClass();
            Constructor.prototype.constructor = Constructor;
            $.extend(Constructor.prototype, spec);
            return Constructor;
        },
        createElement: function (type, config, children) {
            var props = {}, propName;
            config = config || {};
            var key = config.key || null;
            for (propName in config) {
                if (config.hasOwnProperty(propName) && propName !== 'key') {
                    props[propName] = config[propName];
                }
            }
            var childrenLength = arguments.length - 2;
            if (childrenLength === 1) {
                props.children = $.isArray(children) ? children : [children];
            } else if (childrenLength > 1) {
                /*var childArray = Array(childrenLength);
                for (var i = 0; i < childrenLength; i++) {
                    childArray[i] = arguments[i + 2];
                }*/
                props.children = [].slice.call(arguments, 2);
            }
            return new ReactElement(type, key, props);
        },
        render: function (element, container) {
            let componentInstance = instantiateReactComponent(element);
            console.log(componentInstance);
            let markup = componentInstance.mountComponent(React.nextReactRootIndex++);
            console.log(markup);
            $(container).html(markup);
            $(document).trigger('mountReady');
        }
    };
    function instantiateReactComponent(node) {
        //文本节点的情况
        if (typeof node === 'string' || typeof node === 'number') {
            return new ReactDOMTextComponent(node);
        }
        //浏览器默认节点的情况
        if (typeof node === 'object' && typeof node.type === 'string') {
            //注意这里，使用了一种新的component
            return new ReactDOMComponent(node);

        }
        //自定义的元素节点
        if (typeof node === 'object' && typeof node.type === 'function') {
            //注意这里，使用新的component,专门针对自定义元素
            return new ReactCompositeComponent(node);
        }
    }

    function ReactCompositeComponent(element) {
        this._currentElement = element;
        this._rootNodeID = null;
        this._instance = null;
    }

    ReactCompositeComponent.prototype.mountComponent = function (rootID) {
        this._rootNodeID = rootID;
        var publicProps = this._currentElement.props;
        var ReactClass = this._currentElement.type;
        var inst = new ReactClass(publicProps);
        this._instance = inst;
        inst._reactInternalInstance = this;
        if (inst.componentWillMount) {
            inst.componentWillMount();
    }
        var renderedElement = this._instance.render();
        var renderedComponentInstance = instantiateReactComponent(renderedElement);
        this._renderedComponent = renderedComponentInstance; //存起来留作后用

        //拿到渲染之后的字符串内容，将当前的_rootNodeID传给render出的节点
        var renderedMarkup = renderedComponentInstance.mountComponent(this._rootNodeID);

        //之前我们在React.render方法最后触发了mountReady事件，所以这里可以监听，在渲染完成后会触发。
        $(document).on('mountReady', function () {
            //调用inst.componentDidMount
            inst.componentDidMount && inst.componentDidMount();
        });

        return renderedMarkup;
    };
    var HelloMessage1 = React.createClass({
        getInitialState: function () {
            return {type: 'say:'};
        },
        componentWillMount: function () {
            console.log('我就要开始渲染了。。。')
        },
        componentDidMount: function () {
            console.log('我已经渲染好了。。。')
        },
        render: function () {
            return React.createElement("div", null, this.state.type, "Hello ", this.props.name);
        }
    });
    var HelloMessage = React.createClass({
        getInitialState: function () {
            return {type: 'say:'};
        },
        componentWillMount: function () {
            console.log('我就要开始渲染了。。。')
        },
        componentDidMount: function () {
            console.log('我已经渲染好了。。。')
        },
        render: function () {
            return React.createElement("div", null, this.state.type, "Hello ", this.props.name);
        }
    });
    React.render(React.createElement(HelloMessage, {name: "John"}), document.getElementById("container"));
</script>
</body>
</html>